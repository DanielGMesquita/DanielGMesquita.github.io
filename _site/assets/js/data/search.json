[
  
  {
    "title": "Conectando bancos de dados locais - Parte II",
    "url": "/posts/database-local-connection-pt-II/",
    "categories": "Programação, Banco de dados",
    "tags": "programação, postgres, banco de dados, sql",
    "date": "2024-09-02 06:10:00 -0300",
    





    
    "snippet": "Agora que já foi possível conectar o banco postegres usando o JDBC*, podemos seguir em frente e criar os métodos que vão interagir com o banco de dados. Caso não tenha visto a primeira parte, é fun...",
    "content": "Agora que já foi possível conectar o banco postegres usando o JDBC*, podemos seguir em frente e criar os métodos que vão interagir com o banco de dados. Caso não tenha visto a primeira parte, é fundamental que veja.Primeiro, precisamos alimentar as tabelas com algum dado. Isso não vai ser feito via mágica, vamos usar queries SQL mesmo. Na parte I, criamos a tabela product. Agora vamos criar uma tabela order e seu alter incluir dados nela. Indo pelo pgAdmin, utilizando o Queries Tool, podemos incluir algo do tipo:INSERT INTO tb_product (name, price, image_Uri, description) VALUES ('Smartphone Samsung Galaxy', 1200.0, 'https://teste.com/images/1.png', 'Smartphone samsung com SO Android e acesso a 5G'),('Notebook Lenovo', 2500.0, 'https://teste.com/images/2.png', 'Notebook 16GB RAM, Intel i5'),('Earbuds Xiaomi', 400.0, 'https://teste.com/images/3.png', 'Fone de ouvido intra auricular');Feito isso, agora temos uma tabela com dados para podermos explorar.Voltando agora para nossa aplicação, temos que criar a entidade que vai se relacionar com a tabela que criamos:package org.danielmesquita.entities;public class Product {  private long id;  private String name;  private Double price;  private String description;  private String imageUri;  public Product() {}  public Product(long id, String name, Double price, String description, String imageUri) {    this.id = id;    this.name = name;    this.price = price;    this.description = description;    this.imageUri = imageUri;  }  public long getId() {    return id;  }  public void setId(long id) {    this.id = id;  }  public String getName() {    return name;  }  public void setName(String name) {    this.name = name;  }  public Double getPrice() {    return price;  }  public void setPrice(Double price) {    this.price = price;  }  public String getDescription() {    return description;  }  public void setDescription(String description) {    this.description = description;  }  public String getImageUri() {    return imageUri;  }  public void setImageUri(String imageUri) {    this.imageUri = imageUri;  }  @Override  public String toString() {    return \"Product{\" +            \"id=\" + id +            \", name='\" + name + '\\'' +            \", price=\" + price +            \", description='\" + description + '\\'' +            \", imageUri='\" + imageUri + '\\'' +            '}';  }}Com a entidade criada e o banco populado e conectado, agora dá pra brincar com os dados. Você pode passar as queries SQL que vamos utilizar todas para uma classe a parte para critérios de organização:package org.danielmesquita.constants;public class QueriesSQL {  public static final String FIND_ALL_PRODUCTS = \"SELECT * FROM products\";  public static final String INSERT_PRODUCTS =      \"INSERT INTO tb_product (name, price, image_uri, description) VALUES (?, ?, ?, ?)\";  public static final String DELETE_PRODUCT = \"DELETE FROM tb_product WHERE id = ?\";  public static final String UPDATE_PRODUCT =      \"UPDATE tb_product SET name = ?, price = ?, image_uri = ?, description = ? WHERE id = ?\";}E por fim, temos os métodos que irão interagir com o nosso banco de dados:  private static Product instantiateProduct(ResultSet resultSet) throws SQLException {    Product product = new Product();    product.setId(        resultSet.getLong(            \"product_id\")); // product_id instead of id to avoid conflict with Order id    product.setName(resultSet.getString(\"name\"));    product.setPrice(resultSet.getDouble(\"price\"));    product.setDescription(resultSet.getString(\"description\"));    product.setImageUri(resultSet.getString(\"image_uri\"));    return product;  }    public void insertProduct(Product product) {    try (Connection connection = DB.getConnection();        PreparedStatement preparedStatement =            connection.prepareStatement(QueriesSQL.INSERT_PRODUCTS, Statement.RETURN_GENERATED_KEYS)) {      preparedStatement.setString(1, product.getName());      preparedStatement.setDouble(2, product.getPrice());      preparedStatement.setString(3, product.getDescription());      preparedStatement.setString(4, product.getImageUri());      int rowsAffected = preparedStatement.executeUpdate();      if (rowsAffected &gt; 0) {        try (ResultSet resultSet = preparedStatement.getGeneratedKeys()) {          if (resultSet.next()) {            product.setId(resultSet.getLong(1)); // Set the generated ID back to the product object          }        }      }    } catch (SQLException e) {      throw new DbException(e.getMessage());    }  }  public void deleteProductById(long id) {    try (Connection connection = DB.getConnection();        PreparedStatement preparedStatement = connection.prepareStatement(QueriesSQL.DELETE_PRODUCT)) {      preparedStatement.setLong(1, id);      preparedStatement.executeUpdate();    } catch (SQLException e) {      throw new DbException(e.getMessage());    }  }  public void updateProduct(Product product) {    try (Connection connection = DB.getConnection();        PreparedStatement preparedStatement = connection.prepareStatement(QueriesSQL.UPDATE_PRODUCT)) {      preparedStatement.setString(1, product.getName());      preparedStatement.setDouble(2, product.getPrice());      preparedStatement.setString(3, product.getDescription());      preparedStatement.setString(4, product.getImageUri());      preparedStatement.setLong(5, product.getId());      int rowsAffected = preparedStatement.executeUpdate();      if (rowsAffected == 0) {        throw new DbException(\"No product found with the given ID: \" + product.getId());      }    } catch (SQLException e) {      throw new DbException(e.getMessage());    }  }E agora no método main você pode testar o seu banco de dados postgres. Se quiser melhorar, pode separar os métodos nas suas responsabilidades em packages e classes específicas para aprimorar.package org.danielmesquita;import java.sql.*;import java.util.HashMap;import java.util.Map;import org.danielmesquita.constants.QueriesSQL;import org.danielmesquita.dbconfig.DB;import org.danielmesquita.dbconfig.DbException;import org.danielmesquita.entities.Product;public class Application {  public static void main(String[] args) throws SQLException {    Connection connection = DB.getConnection();    Statement statement = connection.createStatement();    ResultSet resultSet = statement.executeQuery(QueriesSQL.FIND_ALL_PRODUCTS);    Map&lt;Long, Product&gt; productMap = new HashMap&lt;&gt;();    while (resultSet.next()) {      Long productId = resultSet.getLong(\"product_id\");      if (productMap.get(productId) == null) {        Product product = instantiateProduct(resultSet);        productMap.put(productId, product);      }      System.out.println(\"Product: \" + productMap.get(productId));    }    Product productToUpdate = new Product();    productToUpdate.setId(1L);  // Supondo que você quer atualizar o produto com ID 1    productToUpdate.setName(\"Samsung Galaxy S21\");    productToUpdate.setPrice(2000.0);    productToUpdate.setDescription(\"The best Android phone ever\");    productToUpdate.setImageUri(\"https://www.samsung.com/samsung-galaxy-s21.jpg\");    updateProduct(productToUpdate);    System.out.println(\"Product updated: \" + productToUpdate);    Product newProduct = new Product();    newProduct.setName(\"Iphone 13\");    newProduct.setPrice(3000.0);    newProduct.setDescription(\"The best iPhone ever\");    newProduct.setImageUri(\"https://apple.com/iphone/4.png\");    insertProduct(newProduct);    System.out.println(\"New product inserted: \" + newProduct);    deleteProductById(newProduct.getId());    System.out.println(\"Product deleted: \" + newProduct.getId());  }  private static Product instantiateProduct(ResultSet resultSet) throws SQLException {    Product product = new Product();    product.setId(        resultSet.getLong(            \"product_id\"));    product.setName(resultSet.getString(\"name\"));    product.setPrice(resultSet.getDouble(\"price\"));    product.setDescription(resultSet.getString(\"description\"));    product.setImageUri(resultSet.getString(\"image_uri\"));    return product;  }  public static void insertProduct(Product product) {    try (Connection connection = DB.getConnection();        PreparedStatement preparedStatement =            connection.prepareStatement(QueriesSQL.INSERT_PRODUCTS, Statement.RETURN_GENERATED_KEYS)) {      preparedStatement.setString(1, product.getName());      preparedStatement.setDouble(2, product.getPrice());      preparedStatement.setString(3, product.getDescription());      preparedStatement.setString(4, product.getImageUri());      int rowsAffected = preparedStatement.executeUpdate();      if (rowsAffected &gt; 0) {        try (ResultSet resultSet = preparedStatement.getGeneratedKeys()) {          if (resultSet.next()) {            product.setId(resultSet.getLong(1));          }        }      }    } catch (SQLException e) {      throw new DbException(e.getMessage());    }  }  public static void deleteProductById(long id) {    try (Connection connection = DB.getConnection();        PreparedStatement preparedStatement = connection.prepareStatement(QueriesSQL.DELETE_PRODUCT)) {      preparedStatement.setLong(1, id);      preparedStatement.executeUpdate();    } catch (SQLException e) {      throw new DbException(e.getMessage());    }  }  public static void updateProduct(Product product) {    try (Connection connection = DB.getConnection();        PreparedStatement preparedStatement = connection.prepareStatement(QueriesSQL.UPDATE_PRODUCT)) {      preparedStatement.setString(1, product.getName());      preparedStatement.setDouble(2, product.getPrice());      preparedStatement.setString(3, product.getDescription());      preparedStatement.setString(4, product.getImageUri());      preparedStatement.setLong(5, product.getId());      int rowsAffected = preparedStatement.executeUpdate();      if (rowsAffected == 0) {        throw new DbException(\"No product found with the given ID: \" + product.getId());      }    } catch (SQLException e) {      throw new DbException(e.getMessage());    }  }}Esse é um exemplo de um CRUD simples utilizando um banco SQL configurado utilizando postgres e o pgAdmin para executar as queries necessárias e visualizar as tabelas. Utilizando o Spring seria muito mais simples devido as funcionalidades que o framework disponibiliza, mas não é o foco deste conteúdo. Aqui é mais pra mostrar como utilizar os bancos no ambiente local.Em breve eu vou trazer aqui a configuração do MongoDB que é um banco NoSQL e como utilizar o Java para manipular os dados.Abraços!___*JDBC (Java Database Connectivity) é uma API (Application Programming Interface) do Java que permite que aplicativos Java se conectem a bancos de dados, enviem consultas SQL e manipulem dados armazenados neles. Basicamente, o JDBC atua como uma ponte entre o código Java e o banco de dados, permitindo que você execute operações como inserir, atualizar, excluir e consultar dados.Componentes Principais do JDBCDriver JDBC: Um driver JDBC é uma implementação específica da API JDBC para um banco de dados particular (como PostgreSQL, MySQL, Oracle, etc.). Ele traduz as chamadas JDBC em comandos específicos do banco de dados.Connection: Representa uma conexão com um banco de dados. Você usa o Connection para interagir com o banco, abrir transações e criar Statements ou PreparedStatements.Statement e PreparedStatement: Objetos usados para executar consultas SQL. Statement é usado para consultas simples, enquanto PreparedStatement permite consultas parametrizadas, o que é mais seguro contra injeções de SQL.ResultSet: Um conjunto de resultados de uma consulta SQL, retornando dados do banco de dados em forma de tabela. O ResultSet é iterado para acessar os dados linha por linha.SQLException: Exceções lançadas quando ocorrem erros durante a interação com o banco de dados.Como o JDBC FuncionaCarregar o Driver JDBC: Carregar a classe do driver para o banco de dados que você deseja usar.Estabelecer uma Conexão: Usar o DriverManager para estabelecer uma conexão com o banco de dados, fornecendo a URL do banco, nome de usuário e senha.Executar Consultas: Usar objetos Statement ou PreparedStatement para executar instruções SQL no banco de dados.Processar os Resultados: Se a consulta retornar dados, você processa os resultados usando o ResultSet.Fechar a Conexão: Após completar as operações, a conexão com o banco de dados deve ser fechada para liberar recursos."
  },
  
  {
    "title": "Conectando bancos de dados locais - Parte I",
    "url": "/posts/database-local-connection-pt-I/",
    "categories": "Programação, Banco de dados",
    "tags": "programação, postgres, banco de dados, sql",
    "date": "2024-09-01 08:10:00 -0300",
    





    
    "snippet": "Uma coisa que todo programador ou estudante back-end precisa ter para fazer qualquer coisa útil, é um banco de dados rodando. Afinal de contas, tudo é CRUD (polêmico) e não se faz um sem um banco d...",
    "content": "Uma coisa que todo programador ou estudante back-end precisa ter para fazer qualquer coisa útil, é um banco de dados rodando. Afinal de contas, tudo é CRUD (polêmico) e não se faz um sem um banco de dados.Uma coisa importante é que existem alguns passos a se configurar um banco de dados local na sua máquina para poder rodar sua aplicação e manusear dados.Eu não vou me aprofundar aqui sobre as diferenças de SQL e NoSQL, tem bastante material por aí, senta a bunda na cadeira e vai estudar. Aqui eu vou falar sobre as diferenças de conexões, como implementar e o que precisa escrever de código. Para este post eu vou usar Java numa abordagem Vanilla, ou seja, sem framework. E para lidar com bancos de dados eu vou usar o Postgres para SQL e MongoDB para NoSQL.Vai ser uma série de 4 posts, este primeiro vou mostrar a configuração do postgres, no segundo a criação de entidades e tabelas e suas relações, no terceiro configuro o MongoDB e no quarto foco em interação de entidades, tabelas e suas relações em um banco NoSQL.Primeiro, para poder utilizar qualquer banco de dados, você precisa instalar e botar pra rodar na sua máquina. No Windows é bem intuitivo porque tudo é instalado via aquivo .exe. No Linux precisamos rodar alguns comandos no terminal pra poder funcionar tudo direitinho. Isso não quer dizer que o ambiente do Windows é melhor pra desenvolver, não se iluda.Presumindo que você já tem uma jdk instalada, pelo menos da 11 pra frente, vamos configurar as coisas. No windows, só ir no site e instalar e no Linux vou mostrar um passo a passo básico aqui.Primeiro você atualiza a lista de packages e então instala o postgres:sudo apt updatesudo apt install postgresql postgresql-contribDepois você precisa iniciar o serviço:sudo systemctl start postgresqlSe quiser que o postgres já inicie quando a máquina ligar:sudo systemctl enable postgresqlPostgreSQL cria um user por default chamado de postgres, então mude para esse usuário:sudo -i -u postgresAcesse o CLI do PostgreSQL:psqlRecomendo mudar a senha pois você vai precisar dela:ALTER USER postgres PASSWORD 'nova_senha';Saia do prompt do postgres:\\qSaia do usuário do postgres:exitPronto, você está com o postgres instalado e pronto pra usar. Para administrar o banco de dados, eu utilizo o pgAdmin4, que você pode usar tanto a aplicação web quanto a versão desktop. Eu utilizo a desktop. Segue o roteiro:Adicione o repositório do pgAdmin:curl https://www.pgadmin.org/static/packages_pgadmin_org.pub | sudo apt-key addsudo sh -c 'echo \"deb https://ftp.postgresql.org/pub/pgadmin/pgadmin4/apt/focal pgadmin4 main\" &gt; /etc/apt/sources.list.d/pgadmin4.list'Atualize a list de packages e instale o pgAdmin:sudo apt updatesudo apt install pgadmin4Na sua instalação pode querer definir se quer a versão desktop pgadmin4-desktop ou o webapp pgadmin4-web. Se preferir usar o web app, recomendo o seguinte passo:sudo /usr/pgadmin4/bin/setup-web.shAgora vamos ao que interessa que é preparar seu banco de dados para ser utilizado. Abrindo o pgAdmin desktop, você clica com o botão direito em Server e vai Register -&gt; Server…Aí você vai dar de cara com General Tab, um menu que pede o name do server, aqui é livre, vamos supor “PostgreSQL Server” e depois você vai em Connection Tabe, coloa no host name localhost, uma vez que você vai rodar local neste caso, a porta padrão do postgres é 5432 e geralmente já vem por default, o usuário postgres que configuramos antes e a senha que você escolheu. Vai de Save e seu novo Server vai estar lá.Depois no server que você criou, pode clicar com o botão direito para criar um database com o nome que você achar melhor. Seu banco de dados não vai ter nenhuma tabela. Então você vai em Schemas -&gt; Tables e clica com o botão direito, lá você pode usar o menu do pgAdmin ou criar as tabelas via query do SQL selecionando Query Tool. Um exemplo de query SQL para você criar uma tabela:create table tb_order_product (    order_id int8 not null,     product_id int8 not null,     primary key (order_id, product_id));Com o postgres configurado e rodando, precisamos agora criar a conexão com a aplicação. Menos palavras e mais código. Segue a implementação que usei no meu caso. Primeiro, para rodar local, você precisa de um arquivo db.properties:dbuser=postgresdbpassword=sua_senhadburl=jdbc:postgresql://localhost:5432/seu_banco_de_dadosuseSSL=false  Desativação do SSL: Quando você define useSSL=false, está explicitamente informando ao driver JDBC que ele não deve usar SSL para a conexão com o banco de dados. Isso é útil em ambientes onde a comunicação SSL não é necessária, como em ambientes de desenvolvimento local, onde a segurança da comunicação entre o aplicativo e o banco de dados pode não ser uma prioridade tão alta.Depois, é necessário criar a classe que ativa a conexão com o banco de dados. Nesta classe eu utilizei 3 métodos: um para criar a conexão com o banco, um para encerrar a conexão e outro que utiliza a classe FileInputStream para acessar o arquivo db.properties e coletar os dados.import java.io.FileInputStream;import java.io.IOException;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.util.Properties;public class DB {  private static Connection conn = null;  public static Connection getConnection() {    if (conn == null) {      try {        Properties props = loadProperties();        String url = props.getProperty(\"dburl\");        String user = props.getProperty(\"dbuser\");        String password = props.getProperty(\"dbpassword\");        conn = DriverManager.getConnection(url, user, password);      } catch (SQLException e) {        throw new DbException(e.getMessage());      }    }    return conn;  }  public static void closeConnection() {    if (conn != null) {      try {        conn.close();      } catch (SQLException e) {        throw new DbException(e.getMessage());      }    }  }  private static Properties loadProperties() {    try (FileInputStream fs = new FileInputStream(\"db.properties\")) {      Properties props = new Properties();      props.load(fs);      return props;    } catch (IOException e) {      throw new DbException(e.getMessage());    }  }}Além disso, criei uma classe DbException que extende RuntimeException para lidar e comunicar os erros que possam acontecer na conexão:public class DbException extends RuntimeException {  private static final long serialVersionUID = 1L;  public DbException(String msg) {    super(msg);  }}É isso, o banco está configurado para uso. No próximo post trago a implementação das entidades e tabelas e como realizar o CRUD propriamente dito.Abraços!"
  },
  
  {
    "title": "Faça seu próprio código",
    "url": "/posts/make-your-own-code/",
    "categories": "Programação, Estudos",
    "tags": "programação, código, estudos, node, javascript",
    "date": "2024-08-26 00:10:00 -0300",
    





    
    "snippet": "No começo dos meus estudos em programação, eu fui um dos vários casos que acompanhou cursos onde o instrutor vai escrevendo o código e ensinando as coisas enquanto o aluno vai replicando.Eu acho qu...",
    "content": "No começo dos meus estudos em programação, eu fui um dos vários casos que acompanhou cursos onde o instrutor vai escrevendo o código e ensinando as coisas enquanto o aluno vai replicando.Eu acho que esse tipo de metodologia tem seu valor, mas depende muito do aluno.Passei quase um ano sem acessar nenhum material e estudar nesse formato. Atualmente estou em uma disciplina na faculdade que o projeto final consiste em uma aplicação de gestão de consultas médicas, envolvendo entidades médico, paciente, consulta e receita. Nada muito complexo. Back-end em Node. Nada muito complexo.E por não parecer complexo, o aluno pode cair na cilada de sair só copiando código do professor, sem ir colocando sua marca ali. Depois de tanto tempo sem acompanhar um material nesse formato, hoje eu me sinto extremamente incomodado em ficar assistindo alguém escrever código. Vou dar um exemplo pra explicar o que eu tenho feito. O print abaixo é do código original da disciplina, da entidade Appointment:import { mongoose } from \"mongoose\";import Pacient from \"./Pacient.js\";import Doctor from \"./Doctor.js\";const Schema = mongoose.Schema;const appointmentSchema = new Schema ({    date: {        type: Date,        required: [true, 'Appointment Date is required.']    },    doctorId: {        type: String,        required: [true, 'DoctorId is required.'],        validate: {            validator: function (v){                const id = new mongoose.Types.ObjectId(v); // convertendo uma string em objeto ID para ser encontrado no banco                return Doctor.exists({_id: id});            },            message: props =&gt;             `DoctorID ${props.value} not found.`         }    },    pacientId: {        type: String,        required: [true, 'PacientId is required.'],        validate: {            validator: function (v){                const id = new mongoose.Types.ObjectId(v); // convertendo uma string em objeto ID para ser encontrado no banco                return Pacient.exists({_id: id});            },            message: props =&gt;             `PacientID ${props.value} not found.`         }    },    createdAt: {        type: Date,        default: Date.now    }});const appointment = mongoose.model('Appointment', appointmentSchema);export default appointment;Você pode notar que existe uma repetição de código para realizar a validação de campos utilizam a mesma lógica. Eu sou muito crítico com código repetido, então criei um utils para validações e limpei um pouco a entidade:import mongoose from \"mongoose\";import Doctor from \"./Doctor.js\";import Pacient from \"./Pacient.js\";import { validateId, idValidationMessage } from './utils/validators.js';const Schema = mongoose.Schema;const appointmentSchema = new Schema ({    date: {        type: Date,        required: [true, 'Appointment date is required'],    },    doctorId: {        type: String,        required: [true, 'Doctor ID is required'],        validate: {            validator: function (v) {                return validateId(v, mongoose, Doctor);            },            message: idValidationMessage,        }    },    pacientId: {        type: String,        required: [true, 'Pacient ID is required'],        validate: {            validator: function (v) {                return validateId(v, mongoose, Pacient);            },            message: idValidationMessage,        }    },    createdAt: {        type: Date,        default: Date.now,    }});const appointment = mongoose.model('Appointment', appointmentSchema);export default appointment;Outra mudança que eu tive que fazer para melhorar a qualidade do código foi nos repositories e controllers. Inicialmente o repository para incluir um novo item no banco, precisava receber um objeto com todos os campos daquela entidade para fazer a lógica de inclusão. Isso não é o errado, o que fica estranho é ter isso declarado diretamente em todo o código, como abaixo:import Doctor from \"../models/Doctor.js\"const getAllDoctors = async () =&gt; {    try{        return await Doctor.find();    }catch(error){        throw new Error(error);    }}const getDoctor = async (id) =&gt; {    try{        return await Doctor.findById(id);    }catch(error){        throw new Error(error);    }}const saveDoctor = async ({ name, login, password, medicalSpecialty, medicalRegistration, email, phone }) =&gt; {    try{        const doctor = new Doctor({ name, login, password, medicalSpecialty, medicalRegistration, email, phone });        return await doctor.save();    }catch(error){        throw new Error(error);    }}const updateDoctor = async (id, { name, login, password, medicalSpecialty, medicalRegistration, email, phone }) =&gt; {    try{        return await Doctor.findByIdAndUpdate(id, { name, login, password, medicalSpecialty, medicalRegistration, email, phone }, { new: true });    }catch(error){        throw new Error(error);    }}const deleteDoctor = async (id) =&gt; {    try{        return await Doctor.findByIdAndDelete(id);    }catch(error){        throw new Error(error);    }}// loginconst getDoctorByLogin = async (login) =&gt; {    try {        return await Doctor.findOne({\"login\": login});    } catch (error) {        throw new Error(error);    }}const doctorRepository = {    getAllDoctors,    getDoctor,    saveDoctor,    updateDoctor,    deleteDoctor,    getDoctorByLogin}export default doctorRepository;Eu também “escondi” toda a lógica de construção do objeto que será enviado para o banco em uma função separada. Assim o repository fica mais “limpo” e não precisa ter a mesma lógica de construção de objeto para todos os campos.import Doctor from \"../models/Doctor.js\"import { buildDoctorData } from \"../utils/BuildDataUtils.js\"const getAllDoctors = async () =&gt; {    return await Doctor.find();}const getDoctor = async (id) =&gt; {    try {        return await Doctor.findById(id);    } catch (error) {        throw new Error(error);    }}const saveDoctor = async (data) =&gt; {    try {        const doctor = new Doctor(buildDoctorData(data));        return await doctor.save();    } catch (error) {        throw new Error(error);    }}const updateDoctor = async (id, data) =&gt; {    try{        return await Doctor.findByIdAndUpdate(id, buildDoctorData(data), { new: true });    }catch(error){        throw new Error(error);    }}const deleteDoctor = async (id) =&gt; {    try {        return await Doctor.findByIdAndUpdate(id);    } catch (error) {        throw new Error(error);    }}const getDoctorByLogin = async (login) =&gt; {    try {        return await Doctor.findOne({\"login\": login});    } catch (error) {        throw new Error(error);    }}const doctorRepository = {    getAllDoctors,    getDoctor,    saveDoctor,    updateDoctor,    deleteDoctor,    getDoctorByLogin}export default doctorRepository;Uma outra edição relevante que fiz foi nos controllers. Todos utilizam o router do express para fazer as chamadas. Todos os controllers tem basicamente as mesmas rotas apra cada entidade. O original não incluía casos para entidades não encontradas no banco, assim como todos as rotas utilizavam um blco try/catch para capturar e passar os erros adiante:import express from \"express\";import AppointmentService from \"../services/AppointmentService.js\";let router = express.Router();router.get('/appointments', async(req, res) =&gt; {    try {        const appointments = await AppointmentService.getAllAppointments();        res.send(appointments);    } catch (error) {        console.log(error);        res.status(500).send(error);    }});router.get('/getAppointment/:id', async(req, res) =&gt; {    const {id} = req.params;    try {        const appointment = await AppointmentService.getAppointment(id);        res.send(appointment);    } catch (error) {        console.log(error);        res.status(500).send(error);    }});router.post('/postAppointment', async(req, res) =&gt; {    const {date, doctorId, pacientId} = req.body;    try {        const appointment = await AppointmentService.saveAppointment({date, doctorId, pacientId});        res.send(appointment);    } catch (error) {        console.log(error);        res.status(500).send(error);    }});router.put('/appointments/:id', async(req, res) =&gt; {    const {id} = req.params;    const {date, doctorId, pacientId} = req.body;    try {        const appointment = await AppointmentService.updateAppointment(id, {date, doctorId, pacientId});        res.send(appointment);    } catch (error) {        console.log(error);        res.status(500).send(error);    }});router.delete('/appointments/:id', async(req, res) =&gt; {    const {id} = req.params;    try {        const appointment = await AppointmentService.deleteAppointment(id);        res.send(appointment);    } catch (error) {        console.log(error);        res.status(500).send(error);    }});router.put('/reschedule/:id', async(req, res) =&gt; {    const {id} = req.params;    const {date} = req.body;    try {        let appointment = await AppointmentService.getAppointment(id);        appointment.date = date;        appointment = await AppointmentService.updateAppointment(id, {date});        res.send(appointment);    } catch (error) {        console.log(error);        res.status(500).send(error);    }});export default router;Então criei um asyncHandler para esse cara:export const asyncHandler = fn =&gt; (req, res, next) =&gt;    Promise.resolve(fn(req, res, next)).catch(next);O que eu decidi fazer foi utilizar um middleware de utilitário do express para lidar com funções assíncronas de maneira mais elegante, automatizando os tratamentos das rotas:1 - O “fn” é uma função assíncrona que eu desejo executar, com a assinatura (req, res, next) que pode retornar uma Promise;2 - O asyncHandler retorna uma nova função rque recebe os mesmos parâmetros que “fn”;3 - Promise.resolve() é utilizado para que garantir que o retorno de “fn” seja tratado como uma promessa, mesmo se “fn” não retornar uma promise explícita (como uma função síncrona, por exemplo);4 - No caso do “.catch(next)” se a promessa retornada por “fn” for rejeitada (ou seja, se um erro ocorrer dentro de “fn”), o .catch(next) captura esse erro e o passa para o middleware de tratamento de erros do Express (chamando a função next com o erro como argumento).import express from \"express\";import AppointmentService from \"../services/AppointmentService.js\";import { buildAppointmentData } from \"../utils/BuildDataUtils.js\";import { asyncHandler } from \"../utils/AsyncHandler.js\";import { errorHandler } from \"../utils/ErrorHandler.js\";let router = express.Router();const notFoundErrorMessage = 'Appointment not found';router.get('/appointments', asyncHandler(async (req, res) =&gt; {    const appointments = await AppointmentService.getAllAppointments();    res.json(appointments);}));router.get('/appointments/getAppointment/:id', asyncHandler(async (req, res) =&gt; {    const { id } = req.params;    const appointment = await AppointmentService.getAppointment(id);    if (appointment) {        res.json(appointment);    } else {        res.status(404).json({ error: notFoundErrorMessage });    }}));router.post('/appointments/createAppointment', asyncHandler(async (req, res) =&gt; {    const data = req.body;    const appointment = await AppointmentService.saveAppointment(buildAppointmentData(data));    res.status(201).json(appointment);}));router.put('/appointments/updateAppointment/:id', asyncHandler(async (req, res) =&gt; {    const { id } = req.params;    const data = req.body;    const updatedAppointment = await AppointmentService.updateAppointment(id, buildAppointmentData(data));    if (updatedAppointment) {        res.json(updatedAppointment);    } else {        res.status(404).json({ error: notFoundErrorMessage });    }}));router.delete('/appointments/deleteAppointment/:id', asyncHandler(async (req, res) =&gt; {    const { id } = req.params;    const deletedAppointment = await AppointmentService.deleteAppointment(id);    if (deletedAppointment) {        res.json(deletedAppointment);    } else {        res.status(404).json({ error: notFoundErrorMessage });    }}));router.put('/appointments/rescheduleAppointment/:id', async(req, res) =&gt; {    const {id} = req.params;    const {date} = req.body;    let appointment = await AppointmentService.getAppointment(id);    if (!appointment) {        return res.status(404).json({ error: notFoundErrorMessage })    }    const rescheduleAppointment = await AppointmentService.updateAppointment(id, {date});    res.json(rescheduleAppointment);});router.use(errorHandler);export default router;Neste caso o asyncHandler simplifica o código, retirando a necessidade de vários blocos try/catch e gerencia os erros de maneira que permita que o Express trate-os de maneira centralizada.Hoje com algum tempo de atuação no mercado, eu já tento sempre implantar melhorias que aumentem a qualidade de código, facilite sua manutenção e torne escalável e fácil de entender, mesmo em projetos de estudo. E eu não faço isso depois de “entregar a atividade”. Eu faço durante a construção do código, assim que pego a ideia do que precisa ser feito, analiso o que pode melhorar e aplico.O mesmo vale pra quem ainda não tem experiência profissional, mesmo nos estudos, a pessoa começa a desenvolver algumas habilidades que ajudam a sair do goHorseX. É muito importante para o aprendizado ter autonomia e iniciativa ao desenvolver projetos de estudos porque você NUNCA vai aprender aquilo se ficar só copiando o que o instrutor está codando.Tente, aplique melhorias, crie outras features, formule hipóteses, tenha visão crítica para buscar melhorias, quebre sua aplicação, leia os logs e o console, vá tratando com a vida real. Na vida real, um código que já sai funcionando bonitinho de cara com tudo bem entregue é coisa rara. E se você se deparar com algum assim, sugiro desconfiar.Você só vai desenvolver novas habilidades se você se expor a novos problemas a serem resolvidos. E copiar código de alguém definitivamente não é um problema.Abraço!"
  },
  
  {
    "title": "Minhas impressões sobre ingressar na área de TI - Parte III",
    "url": "/posts/start-in-IT-pt-III-copy/",
    "categories": "Carreira, Programação",
    "tags": "carreira, programação, juninho, inglês",
    "date": "2024-08-22 09:10:00 -0300",
    





    
    "snippet": "Nas últimas postagens, abordei sobre aspectos técnicos e comportamentais que, baseados na minha experiência, achei legal compartilhar para as pessoas interessadas em ingressar na área de TI.Faltou ...",
    "content": "Nas últimas postagens, abordei sobre aspectos técnicos e comportamentais que, baseados na minha experiência, achei legal compartilhar para as pessoas interessadas em ingressar na área de TI.Faltou um ponto importante que merece uma abordagem a parte, o inglês.Hoje em dia com as IAs generativas, tem muita gente abandonando literatura e documentação. O que é um equívoco, pois os materiais técnicos não correm risco de alucinar e não concordam com você quando você tá errado.Muitos materiais de qualidade estão em inglês. E infelizmente, a maioria dos materiais pioneiros ainda são produzidos lá fora primeiro. A maioria das empresas que você vai trabalhar, mesmo as brasileiras, por padrão utilizam o inglês para escrever códigos, funções, nomes de variáveis, documentação etc. Então é de suma importância ter conhecimento sobre o idioma pra poder se inserir mais rápido em qualquer contexto.E um outro ponto importante é que saber inglês abre novos portais na sua vida pessoa e profissional.Recentemente eu iniciei minha carreira em uma empresa do exterior trabalhando remoto do Brasil. Eu nunca fiz curso de inglês ou intercâmbio porque quando era novo minha mãe tinha mal dinheiro pra pagar minha escola e depois de velho, difícil você tirar 6 meses sabáticos pra intercâmbio quando tem contas a pagar. Então aprendi como qualquer jovem sem recurso: fiz o que dava. Aprendi na curiosidade de entender os jogos, me expuso voluntariamente a leituras em inglês, assistindo filmes e séries legendadas, aos poucos tirando as legendas. Isso tudo me ajudou muito na leitura, escrita e compreensão.Mas a conversação é um caso a parte. Eu tinha total condições de compreender qualquer coisa dita a mim. Mas tinha uma grande insegurança ao falar. Me juntei a alguns grupos de discussões de negócios em redes sociais há uns anos atrás pra poder trocar ideia sobre vários assuntos “business” e poder destravar. Mesmo assim, não me sentia “fluente” ao ponto de fazer uma entrevista. Mas foi ao fazer minha primeira entrevista em inglês que vi que eu sabia mais do que imaginava. Conseguir fazer uma entrevista técnica com live coding, tudo em inglês foi algo que quebrou as minhas resistências.Acredito que muitas pessoas passam pelo mesmo problema: a falta de confiança. E a melhor maneira é se expor. E gringo julga menos sotaque e pronúncia do que brasileiro. Não leve em consideração se você já fez algum processo seletivo no BR e julgaram você mal pelo seu sotaque ou algo do tipo, a galera aqui é chata pra caralho com isso. Querem só nível 10 na escala Geller do meu amigo Leonardo Marconi.Portanto, se exponha, fale inglês com estrangeiros, vai aprendendo, errando, melhorando, estudando. Não esqueça da leitura, você constrói um vocabulário melhor quanto mais você lê. Não adianta falar bem se só sabe falar bosta.Se alguém estiver lendo isso e quiser dar alguma sugestão sobre assuntos pra quem quer entrar em TI, só entrar em contato.Espero ter ajudado!Abraço!"
  },
  
  {
    "title": "Minhas impressões sobre ingressar na área de TI - Parte II",
    "url": "/posts/start-in-IT-pt-II/",
    "categories": "Carreira, Programação",
    "tags": "carreira, programação, juninho",
    "date": "2024-08-20 02:10:00 -0300",
    





    
    "snippet": "Eu não sou especialista em nada, tudo o que eu falo é baseado na minha experiência, não quero ser influencer nem monetizar isso. Vou tentar condensar um pouco o meu caminho pra conseguir iniciar em...",
    "content": "Eu não sou especialista em nada, tudo o que eu falo é baseado na minha experiência, não quero ser influencer nem monetizar isso. Vou tentar condensar um pouco o meu caminho pra conseguir iniciar em TI sem me ater muito a sacrifícios pessoais, porque isso cada um vai viver os seus.Acredito que a primeira coisa é pesquisar sobre carreiras em TI, back, front, devops, cybersec, dados etc e entender o que quer fazer. Muito ruim você tentar iniciar uma coisa sem ter noção de onde quer chegar. Eu demorei cerca de 8 meses de estudos pulando de galho em galho, seguindo hypes e papo de vendedor de curso.Na parte de estudos, é muito importante pegar noções básicas de algoritmos e estruturas de dados antes de qualquer linguagem ou framework e entender se programar é pra você mesmo. Muita gente começa empolgada com a ideia de trabalhar remoto, trabalhar em casa e acha que a rotina é tranquila, mas é uma carreira que exige bastante, em alguns momentos você vai ter uma carga de trabalho puxada e todos os dias você acorda obsoleto se não se atualizar. Se não gostar, no longo prazo pode ser uma grande frustração.Sobre comunidade, eu tenho uma opinião não muito agradável sobre a bolha dev, então se cerce de poucos e bons. No começo ter alguém que já tá na área que possa te dar uma orientação pode ajudar muito a não perder tempo estudando coisas sem necessidade e até mesmo com uma indicação. E ao se posicionar em redes sociais, é importante ter esse pensamento. Tem pessoas muito boas tecnicamentes e como humanos por aí, construir boas conexões com essas pessoas vai ajudar muito.Não se empolga com hype de rede social, não vai atrás de influencer e foca no que dá empregabilidade. Que depois que você tiver na prática, sempre vai ter que estar aberto para aprender novas tecnologias. Você só vai escolher 100% das tecnologias que vai trabalhar se um dia você for lidar com um projeto só seu. Enquanto for trabalhar para os outros, vai precisar ser flexível.Espero que tenha sido útil.Abraço!"
  },
  
  {
    "title": "Minhas impressões sobre ingressar na área de TI - Parte I",
    "url": "/posts/start-in-IT-pt-I/",
    "categories": "Carreira, Programação",
    "tags": "carreira, programação, juninho",
    "date": "2024-08-19 15:45:00 -0300",
    





    
    "snippet": "Algumas pessoas já vieram conversar comigo sobre iniciar em TI e transição de carreira. Muito pela experiência que tive fazendo uma mudança de carreira há alguns anos atrás.Tem algumas perguntas fr...",
    "content": "Algumas pessoas já vieram conversar comigo sobre iniciar em TI e transição de carreira. Muito pela experiência que tive fazendo uma mudança de carreira há alguns anos atrás.Tem algumas perguntas frequentes que costumam fazer e eu vou deixar aqui as minhas opiniões baseadas na minha vivência. Caso você tenha outras sugestões, pode deixar aqui nos comentários que certamente vai ajudar alguém.❓ Devo fazer uma faculdade de TI?➡ Eu recomendo. Apesar de não ser fundamental para muitas vagas, a vivência acadêmica faz diferença. Mas não considere isso um diferencial. Porém, muitas vagas pedem, então é bom ficar ligado. E considerando que estágio hoje é a porta de entrada mais fácil do que começar como Júnior tendo zero experiência, é um caminho a se considerar.❓Com qual linguagem de programação eu deveria começar?➡ Qualquer coisa pouco complexa pra não assustar de início e poder pegar o básico (Python ou JS), e depois passar para outras de acordo com os planos seguintes. O que importa é se familiarizar com lógica de programação, ter contato com estruturas de controle, algoritmos e estrutura de dados. Depois é mais fácil você se adaptar a mudanças de linguagens;❓ Todo programador deveria saber C?➡ Não. Eu não sei C a fundo. Mas se precisar eu aprendo. E é essa abertura pra aprender que devemos ter uma vez que pegamos bem as bases.❓ Qual deveria ser a minha segunda linguagem?➡ Sempre bom ter noções de JavaScript para entender o front-end e alguma outra de back-end (Java, Python, C#). Mas recomendo também pegar banco de dados, principalmente SQL por ser amplamente utilizada e ter muitos detalhes, alguns bem pequenos, que fazem grande diferença. Não a nível DBA, mas entender as interações de uma aplicação com um banco de dados, como acontece em um CRUD por exemplo.❓ Não tenho como pagar uma graduação e nem curso, e agora?➡ Tem a Universidade Brasileira Livre no github que tem um curso de ciência da computação, por assim dizer, na faixa. Além de vários cursos gratuitos por aí como do Gustavo Guanabara no Curso em Vídeo e vindo pra algo mais nichado da minha rede o Jose Santos que tem um canal no youtube com um curso completão de programação com C#. Mas não é sobre C#, independente da linguagem, ele aborda conceitos fundamentais de programação.❓ Preciso ter um setup de ultima geração para estudar programação?➡ Eu comecei com um notebook meia boca. Setup cheio de luz de natal é luxo. Vale a pena investir em coisas melhores quando você tiver dinheiro pra isso.❓ Como saber a trilha que devo seguir para a tecnologia que escolhi?➡ Tem um site muito bom chamado Roadmap contendo trilhas intuitivas de diversas tecnologias. Mas você também pode pesquisar no Google, por exemplo: “roadmap backend”.❓ O que fazer diante de tantas informações na internet?➡ Aprender a pesquisar e corroborar as informações é sempre a melhor escolha. Infelizmente, só a experiência nos ensina a filtrar muitas coisas que vemos por aí. E sair um pouco de redes sociais ajuda.❓ Tem alguma dica para quem está no inicio?➡ Paciência, disciplina pra estudar, não pular as etapas das bases de algoritmos, estruturas de dados, git e coisas do tipo, não cair em hype de rede social e buscar se conectar com pessoas experientes dispostas a ajudar. Ter gente boa aconselhando faz muita diferença e eu não tive isso no meu início.Abraços!"
  },
  
  {
    "title": "Papos abstratos",
    "url": "/posts/abstract-talks/",
    "categories": "Programação, Orientação a objetos",
    "tags": "programação, poo, abstração",
    "date": "2024-08-18 20:43:00 -0300",
    





    
    "snippet": "Abstração é um termo bastante comum quando falamos de programação. Mas, o que exatamente isso significa? Pintura?Para entender melhor, vamos explorar o conceito dentro do contexto da Programação Or...",
    "content": "Abstração é um termo bastante comum quando falamos de programação. Mas, o que exatamente isso significa? Pintura?Para entender melhor, vamos explorar o conceito dentro do contexto da Programação Orientada a Objetos (POO), que utiliza classes e objetos.Imagine que você vai a um restaurante. No restaurante, há uma série de elementos com os quais você interage para conseguir sua refeição. Esses elementos vão desde objetos (como mesas e cadeiras) até ações realizadas por você ou pelos funcionários do restaurante.No conceito de POO, uma classe é uma abstração que define as propriedades e comportamentos de um tipo de objeto. Por exemplo, a classe Restaurante pode abstrair características como o tipo de comida que serve, o grau de avaliação, a quantidade de lugares, entre outros. Além disso, a classe pode definir comportamentos como preparar comida, fazer uma entrega e receber clientes.A ideia principal da abstração é simplificar sistemas complexos, focando nas partes essenciais e ocultando os detalhes mais complicados e desnecessários. Isso permite que o desenvolvedor trabalhe com sistemas complexos criando representações mais simples e gerais dos objetos.No caso do restaurante, você não precisa saber o nome do cozinheiro, como o prédio foi construído, ou onde os ingredientes foram comprados. O que você precisa saber é o que o restaurante faz: recebe pessoas, prepara e serve comida, e também faz entregas. Estes são os métodos da classe. E tem a estrutura para isso, que são seus atributos.Essa abordagem ajuda a gerenciar a complexidade e permite uma visão mais clara e objetiva do sistema."
  },
  
  {
    "title": "HTTP e seus métodos",
    "url": "/posts/http-methods/",
    "categories": "Internet, HTTP",
    "tags": "internet, http, basics",
    "date": "2024-08-16 21:04:00 -0300",
    





    
    "snippet": "Seja você frontend ou backend, precisa saber como funciona a web.Nas imagem abaixo, você pode ver que no início do roadmap de back-end, é um dos itens básicos.Um erro que muito dev iniciante comete...",
    "content": "Seja você frontend ou backend, precisa saber como funciona a web.Nas imagem abaixo, você pode ver que no início do roadmap de back-end, é um dos itens básicos.Um erro que muito dev iniciante comete é já sair escrevendo linhas códigos sem saber como tudo funciona por baixo dos panos.E uma das bases é o HTTP. Como eu falei no último post, o protocolo HTTP é utilizado para comunicação cliente-servidor para troca de informação através de requisições.Os métodos mais utilizados para realizar essas trocas são:1 - GET: utilizado pra solicitar dados do servidor,2 - POST: utilizado para submeter uma inclusão de uma entidade a um conteúdo específico do lado do servidor;3 - PUT: Utilizado para substituir os dados existentes de um recurso específico;4 - DELETE: Remove um recurso específico.Importante ressaltar que esses métodos devem ser levado em conta na construção de uma API. Utilizar um GET pra fazer uma alteração numa base de dados do lado do servidor, por exemplo, não é adequado por ser possível visualizar dados sensíveis via URL da requisição.E pra quem ficou curioso sobre os roadmaps, você pode conferir a ferramenta aqui.Abraços!"
  },
  
  {
    "title": "HTTP basicão",
    "url": "/posts/http-basics/",
    "categories": "Internet, HTTP",
    "tags": "internet, http, basics",
    "date": "2024-08-15 21:04:00 -0300",
    





    
    "snippet": "Eu sei que você que adora fazer projeto dizendo que tá consumindo API sem nem saber como aquilo funciona.Você sabe do que se trata HTTP?Não se culpe por sair codando sem saber que raios faz HTTP, e...",
    "content": "Eu sei que você que adora fazer projeto dizendo que tá consumindo API sem nem saber como aquilo funciona.Você sabe do que se trata HTTP?Não se culpe por sair codando sem saber que raios faz HTTP, eu era assim. Muitos desses cursos não incentivam o conhecimento de base da web.Hypertext Transfer Protocol (HTTP) é um protocolo (sistema de regras que define como os dados vão ser trafegados) que permite que o usuário obtenha recursos, como por exemplo um documento HTML da vida.É um protocolo cliente-servidor, parte do destinatário a requisição (request) e o servidor atende essa requisição retornando uma resposta (response).Exemplo bem simples pra ficar mais claro: você envia um post aqui no LinkedIn, isso é uma requisição HTTP que envia uma solicitação de inclusão de um dado novo para o servidor, que por sua vez executa a requisição e retorna a resposta.Essa resposta vem com um status, que sinaliza se a requisição foi bem sucedida ou se algum erro aconteceu durante sua execução.Existem métodos diferentes para cada tipo de requisição. Mas isso fica pra um próximo post.Aqui eu deixo uma maneira que ilustra bem legal os status de resposta de requisições HTTP.Abraços!"
  }
  
]

